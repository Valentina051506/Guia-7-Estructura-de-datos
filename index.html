<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Guía 7 - Árboles Binarios</title>

  <!-- Fuente moderna -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg: #f3ecfa;
      --card: #ffffff;
      --muted: #6b5f82;
      --accent: #7a42c5;
      --accent-2: #b49dd8;
      --text: #2b2640;
      --radius: 12px;
      --shadow: 0 8px 30px rgba(121,84,169,0.08);
      --code-bg: #0f1220;
      --code-text: #e8e6f6;
    }
    :root.dark{
      --bg: #0f1020;
      --card: #0f1220;
      --muted: #bfb8d9;
      --accent: #9b7be0;
      --accent-2: #6b4ea8;
      --text: #e8e6f6;
      --shadow: 0 8px 30px rgba(0,0,0,0.6);
      --code-bg: #11121a;
      --code-text: #f3f1ff;
    }

    html,body{
      margin:0;
      padding:0;
      font-family: "Inter", system-ui, -apple-system, "Segoe UI", Roboto, Arial;
      background: linear-gradient(180deg,var(--bg), #efe7fb 240px);
      color:var(--text);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      line-height:1.65;
      min-height:100vh;
    }

    .container{
      max-width:1100px;
      margin:32px auto;
      padding:18px;
    }

    header.top{
      display:flex;
      gap:18px;
      align-items:center;
      background: linear-gradient(90deg,var(--accent-2),var(--accent));
      color:#fff;
      padding:22px;
      border-radius:14px;
      box-shadow:var(--shadow);
    }

    .brand{
      display:flex;
      gap:14px;
      align-items:center;
      flex:1;
    }
    .logo{
      width:72px;
      height:72px;
      border-radius:10px;
      background:rgba(255,255,255,0.08);
      display:grid;
      place-items:center;
    }
    .logo svg{ width:44px; height:44px; opacity:0.98; }

    header h1{ margin:0; font-size:18px; font-weight:700; }
    .meta{ font-size:13px; opacity:0.95; margin-top:6px; }

    .actions{
      display:flex;
      gap:8px;
    }
    .btn{
      background:rgba(255,255,255,0.12);
      color:#fff;
      border:none;
      padding:8px 12px;
      border-radius:10px;
      cursor:pointer;
      font-weight:600;
      font-size:13px;
    }
    .btn.secondary{ background:rgba(255,255,255,0.08); }

    main.layout{
      display:grid;
      grid-template-columns: 260px 1fr;
      gap:22px;
      margin-top:20px;
    }

    aside.toc{
      position:sticky;
      top:30px;
      background:var(--card);
      border-radius:12px;
      padding:14px;
      box-shadow:var(--shadow);
      border:1px solid rgba(124,86,187,0.06);
      height:fit-content;
    }
    .toc h3{ margin:0 0 8px 0; font-size:14px; color:var(--muted); }
    .toc a{ display:block; color:var(--accent); text-decoration:none; padding:6px 0; font-size:14px; }
    .toc a:hover{ text-decoration:underline; }

    .content{ display:flex; flex-direction:column; gap:18px; }

    section.card{
      background: linear-gradient(180deg,var(--card), rgba(255,255,255,0.85));
      border-radius:12px;
      padding:22px;
      box-shadow:var(--shadow);
      border-left:8px solid var(--accent-2);
    }
    section.card h2{ margin-top:0; color:var(--accent-2); }
    section.card h3{ color:var(--muted); margin-bottom:8px; }

    p{ margin:10px 0; text-align:justify; }
    ul,ol{ margin:10px 0 10px 22px; }

    /* tabla comparativa */
    table.compare{ width:100%; border-collapse:collapse; margin-top:12px; }
    table.compare th, table.compare td{ border:1px solid rgba(124,86,187,0.08); padding:10px; text-align:left; vertical-align:top; }
    table.compare thead th{ background:linear-gradient(90deg, rgba(180,157,216,0.15), rgba(122,66,197,0.06)); color:var(--accent); }

    /* bloque de código estilo oscuro */
    pre.codeblock{ background:var(--code-bg); color:var(--code-text); padding:16px; border-radius:10px; overflow:auto; font-family: 'Courier New', monospace; font-size:13px; }

    .small{ font-size:13px; color:var(--muted); }

    footer{ margin:28px 0; color:var(--muted); text-align:center; font-size:13px; }

    @media (max-width:980px){
      main.layout{ grid-template-columns: 1fr; }
      aside.toc{ position:relative; order:2; top:auto; }
    }

    @media print{
      header.top, .toc, .actions { display:none !important; }
      body{ background:white; color:black; }
      .container{ padding:0; margin:0; max-width:100%; }
      section.card{ border-left:4px solid #ddd; box-shadow:none; }
      pre.codeblock{ background:#f4f4f4; color:#000; }
    }
  </style>
</head>
<body>
  <div class="container">
    <header class="top" role="banner">
      <div class="brand">
        <div class="logo" aria-hidden="true">
          <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <rect x="1" y="17" width="22" height="6" rx="2" fill="rgba(255,255,255,0.12)"/>
            <circle cx="8" cy="7" r="3.2" fill="white" opacity="0.95"/>
            <circle cx="16" cy="7" r="3.2" fill="white" opacity="0.95"/>
            <rect x="11" y="8" width="2.2" height="8" rx="1" fill="white" opacity="0.95"/>
          </svg>
        </div>
        <div>
          <h1>Guía de Laboratorio No.7 - Árboles Binarios</h1>
          <div class="meta"><strong>Universidad Manuela Beltrán</strong> • Estructuras de Datos • Estudiante: <strong>Natalia Omaña</strong></div>
          </div>
      </div>

      <div class="actions" role="toolbar" aria-label="Controles">
        <button class="btn secondary" onclick="window.print()" title="Imprimir guía">Imprimir</button>
        <button class="btn" id="theme-toggle" title="Alternar modo oscuro">Modo</button>
      </div>
    </header>

    <main class="layout" id="main">
      <aside class="toc" aria-label="Tabla de contenidos">
        <h3>Contenido</h3>
        <a href="#introduccion">Introducción</a>
        <a href="#preguntas-intro">Preguntas y Actividades</a>
        <a href="#situaciones">10 situaciones reales</a>
        <a href="#comparativo">Comparativo: B / B+ / AVL</a>
        <a href="#huffman">Huffman (explicación + código)</a>
        <a href="#presaberes">Presaberes (test)</a>
        <a href="#preguntas-orientadoras">Preguntas Orientadoras</a>
        <a href="#trabajo-autonomo">Trabajo Autónomo (resumen)</a>
        <a href="#bibliografia">Bibliografía</a>
      </aside>

      <div class="content">
        <section id="introduccion" class="card" aria-labelledby="intro-title">
          <h2 id="intro-title">Introducción</h2>
          <p>Los árboles binarios constituyen una de las estructuras de datos más importantes en la programación moderna. Son la base de sistemas de organización y búsqueda que permiten optimizar el acceso a la información. En su forma más simple, un árbol binario se compone de nodos donde cada uno puede tener hasta dos hijos, denominados hijo izquierdo e hijo derecho. Este modelo de jerarquía resulta muy útil para representar relaciones dependientes o jerárquicas, como estructuras familiares, jerarquías organizacionales o la forma en la que los sistemas operativos almacenan archivos.</p>
          <p>En el contexto de la ingeniería de software, los árboles binarios ofrecen una representación eficiente de estructuras dinámicas que cambian con el tiempo. Su naturaleza recursiva permite crear algoritmos elegantes para operaciones como búsqueda, inserción, eliminación o recorrido. En el lenguaje Java, su implementación requiere comprender principios de la Programación Orientada a Objetos, dado que cada nodo se puede considerar como un objeto que contiene información y referencias a otros objetos (sus hijos).</p>
          <p>Su aplicación abarca desde la gestión de bases de datos (árboles B y B+), la representación de expresiones algebraicas, hasta sistemas de compresión de datos como el algoritmo de Huffman. Esta práctica busca fortalecer el pensamiento lógico y algorítmico del estudiante a través del diseño e implementación de estructuras jerárquicas que imitan procesos del mundo real.</p>
        </section>

        <section id="preguntas-intro" class="card">
          <h2>Preguntas y Actividades de la Guía</h2>
          <p>En esta sección están las preguntas reales que solicita la guía y las respuestas elaboradas.</p>
          <ol>
            <li><strong>Elabore una lista de por lo menos 10 situaciones en las que se presente la estructura de árbol.</strong>
              <p>Ver sección <a href="#situaciones">"10 situaciones reales"</a> para la lista extendida y ejemplos prácticos.</p>
            </li>

            <li><strong>Consulte acerca de los árboles B, B+ y AVL. Elabore un cuadro comparativo.</strong>
              <p>Ver sección <a href="#comparativo">"Comparativo: B / B+ / AVL"</a> para la tabla completa con ventajas, desventajas y usos típicos.</p>
            </li>

            <li><strong>Investigue sobre: Árbol de códigos Huffman — explique su aplicación en media página y describa su funcionamiento. Construya el código de este algoritmo y explíquelo con ejemplos.</strong>
              <p>Ver sección <a href="#huffman">"Huffman (explicación + código)"</a> donde incluimos una explicación de ~media página, el código Java funcional y un ejemplo de codificación/decodificación.</p>
            </li>

            <li><strong>Desarrollo de guía / Presaberes requeridos</strong>
              <p>Se incluye la sección <a href="#presaberes">"Presaberes"</a> con las preguntas tipo test y sus respuestas correctas.</p>
            </li>

            <li><strong>Teniendo en cuenta la terminología que se utiliza en teoría de grafos. Identifique la definición correcta de un grafo.</strong>
              <p class="small"><em>Respuesta correcta:</em> "Un conjunto de vértices y aristas, tal que cada arista está asociada a un par".</p>
            </li>

            <li><strong>A partir de los conocimientos adquiridos en la guía. Elija la opción que mejor defina a un árbol binario.</strong>
              <p class="small"><em>Respuesta correcta:</em> "Un árbol binario es un árbol con raíz en el que cada vértice tiene ningún hijo, un hijo o dos hijos."</p>
            </li>

            <li><strong>En los recorridos que se hace a un árbol, este método se recorre cada uno de los subárboles luego se pasa por la raíz. ¿Cuál es?</strong>
              <p class="small"><em>Respuesta correcta:</em> <strong>Post-Orden</strong>.</p>
            </li>

          </ol>
        </section>

        <section id="situaciones" class="card">
          <h2>10 situaciones reales donde se usa la estructura de árbol</h2>
          <ol>
            <li><strong>Sistemas de archivos:</strong> La organización de directorios y archivos (folders) en sistemas operativos es un árbol donde cada carpeta puede contener subcarpetas y archivos. Ejemplo: \root → /home → /user → /documents.</li>
            <li><strong>Índices en bases de datos:</strong> Estructuras B y B+ se usan para indexar columnas y acelerar búsquedas y rangos en grandes volúmenes de datos almacenados en disco.</li>
            <li><strong>Compresión de datos (Huffman):</strong> El algoritmo de Huffman genera un árbol para asignar códigos de longitud variable según la frecuencia de símbolos.</li>
            <li><strong>Compiladores y parsers:</strong> Los árboles sintácticos abstractos (AST) representan la estructura de sentencias y expresiones de un programa para su análisis y optimización.</li>
            <li><strong>Motores de búsqueda y autocompletado:</strong> Tries y árboles de prefijos facilitan la búsqueda rápida de sugerencias y palabras a partir de prefijos ingresados.</li>
            <li><strong>Inteligencia artificial (árboles de decisión):</strong> Para clasificación y toma de decisiones (por ejemplo, algoritmos CART, ID3).</li>
            <li><strong>Representación de expresiones matemáticas:</strong> Los árboles de expresión se usan para evaluar y transformar fórmulas algebraicas o lógicas.</li>
            <li><strong>Jerarquías organizacionales:</strong> Organigramas y estructuras empresariales, donde cada puesto puede reportar a uno superior.</li>
            <li><strong>DOM en navegadores:</strong> El Document Object Model (DOM) representa HTML/XML como un árbol de nodos que permite manipular el documento con JavaScript.</li>
            <li><strong>Sistemas de archivos de bases de datos y B-trees en almacenamiento:</strong> Organización y recuperación eficiente de registros mediante nodos y punteros en discos.</li>
          </ol>

          <p>Si deseas, puedo expandir cada situación con un pequeño diagrama o ejemplo de código que ilustre su uso — dime cuáles quieres profundizar.</p>
        </section>

        <section id="comparativo" class="card">
          <h2>Comparativo: Árbol B • Árbol B+ • Árbol AVL</h2>
          <table class="compare" aria-label="Comparativo B B+ AVL">
            <thead>
              <tr>
                <th>Característica</th>
                <th>Árbol B</th>
                <th>Árbol B+</th>
                <th>Árbol AVL</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Definición</td>
                <td>Árbol balanceado de orden m; claves y punteros pueden estar en nodos internos y hojas.</td>
                <td>Variación de B: las claves reales se almacenan solo en hojas; nodos internos guían búsquedas; hojas enlazadas para escaneo secuencial.</td>
                <td>Árbol binario de búsqueda autobalanceado que mantiene la diferencia de altura entre hijos ≤ 1 mediante rotaciones.</td>
              </tr>
              <tr>
                <td>Balance</td>
                <td>Balance por número de claves por nodo (alto fan-out → menor altura).</td>
                <td>Igual que B; hojas enlazadas facilitan lecturas secuenciales y rangos.</td>
                <td>Balance estricto por altura (factor de equilibrio -1,0,+1).</td>
              </tr>
              <tr>
                <td>Operaciones (complejidad)</td>
                <td>Buscar/Insertar/Eliminar: O(log n) en términos de altura; optimizado para I/O con alto fan-out.</td>
                <td>Similares a B; más eficiente para escaneos de rango y lecturas secuenciales.</td>
                <td>Buscar/Insertar/Eliminar: O(log n) en memoria; rotaciones mantienen balance tras operaciones.</td>
              </tr>
              <tr>
                <td>Uso típico</td>
                <td>Índices en bases de datos y sistemas de ficheros donde el acceso a disco es costoso.</td>
                <td>Índices en bases de datos que requieren lectura de rangos y ordenación eficiente.</td>
                <td>Estructuras en memoria donde la búsqueda y actualización deben ser rápidas (ej. mapas ordenados).</td>
              </tr>
              <tr>
                <td>Ventaja</td>
                <td>Reduce accesos a disco (alto fan-out).</td>
                <td>Mejor para escaneos por rango; hojas enlazadas simplifican recorridos secuenciales.</td>
                <td>Altamente eficiente en memoria; garantiza búsqueda rápida y balanceada.</td>
              </tr>
              <tr>
                <td>Desventaja</td>
                <td>Complejidad en splits/merges y manejo de nodos parcialmente llenos.</td>
                <td>Mayor uso de espacio en hojas; implementación más compleja que B.</td>
                <td>Rotaciones frecuentes y sobrecosto en inserciones/borrados en casos intensivos.</td>
              </tr>
            </tbody>
          </table>
        </section>

        <section id="huffman" class="card">
          <h2>Árbol de códigos Huffman</h2>
          <h3>Explicación y aplicación (≈ media página)</h3>
          <p>El algoritmo de Huffman es un método de compresión sin pérdida que genera códigos de longitud variable para cada símbolo de un alfabeto, asignando códigos más cortos a símbolos más frecuentes y códigos más largos a símbolos raros. La construcción del código se basa en la construcción de un árbol binario de Huffman: cada símbolo se representa inicialmente como una hoja con su frecuencia. Luego, se seleccionan las dos hojas (o subárboles) con menor frecuencia, se combinan en un nuevo nodo cuya frecuencia es la suma y se reinsertan en la estructura. Repetir hasta que quede un único nodo raíz. Los códigos se obtienen leyendo el árbol desde la raíz a cada hoja (por ejemplo, tomar '0' para la rama izquierda y '1' para la derecha).</p>

          <p>Esta técnica es ampliamente utilizada en formatos de compresión (ZIP, PNG) y en cualquier escenario donde se conozca la distribución de probabilidades de los símbolos. Huffman garantiza que los códigos generados son prefijos (ningún código es prefijo de otro), lo que permite una decodificación única y sin ambigüedad. Es eficiente y relativamente simple de implementar cuando se cuenta con una tabla de frecuencias.</p>

          <h3>Implementación (Java) — código funcional</h3>
          <pre class="codeblock">// HuffmanCoding.java
import java.util.*;

public class HuffmanCoding {

    static class Node implements Comparable&lt;Node&gt; {
        char ch;
        int freq;
        Node left, right;
        Node(char ch, int freq) { this.ch = ch; this.freq = freq; }
        Node(int freq, Node left, Node right) { this.ch = '\0'; this.freq = freq; this.left = left; this.right = right; }
        public int compareTo(Node o) { return Integer.compare(this.freq, o.freq); }
        boolean isLeaf() { return left == null &amp;&amp; right == null; }
    }

    public static Node buildTree(Map&lt;Character,Integer&gt; freqMap) {
        PriorityQueue&lt;Node&gt; pq = new PriorityQueue&lt;&gt;();
        for (Map.Entry&lt;Character,Integer&gt; e : freqMap.entrySet()) pq.add(new Node(e.getKey(), e.getValue()));
        if (pq.size() == 1) pq.add(new Node('\0', 0));
        while (pq.size() &gt; 1) {
            Node a = pq.poll();
            Node b = pq.poll();
            pq.add(new Node(a.freq + b.freq, a, b));
        }
        return pq.poll();
    }

    public static void buildCodes(Node node, String prefix, Map&lt;Character,String&gt; codes) {
        if (node == null) return;
        if (node.isLeaf()) {
            codes.put(node.ch, prefix.length() &gt; 0 ? prefix : "0");
        } else {
            buildCodes(node.left, prefix + "0", codes);
            buildCodes(node.right, prefix + "1", codes);
        }
    }

    public static String encode(String text, Map&lt;Character,String&gt; codes) {
        StringBuilder sb = new StringBuilder();
        for (char c : text.toCharArray()) sb.append(codes.get(c));
        return sb.toString();
    }

    public static String decode(String bits, Node root) {
        StringBuilder sb = new StringBuilder();
        Node cur = root;
        for (int i = 0; i &lt; bits.length(); i++) {
            cur = bits.charAt(i) == '0' ? cur.left : cur.right;
            if (cur.isLeaf()) { sb.append(cur.ch); cur = root; }
        }
        return sb.toString();
    }

    public static void main(String[] args) {
        String message = "hola mundo"; // ejemplo
        Map&lt;Character,Integer&gt; freq = new HashMap&lt;&gt;();
        for (char c : message.toCharArray()) freq.put(c, freq.getOrDefault(c, 0) + 1);

        Node root = buildTree(freq);
        Map&lt;Character,String&gt; codes = new HashMap&lt;&gt;();
        buildCodes(root, "", codes);

        System.out.println("Frecuencias: " + freq);
        System.out.println("Códigos Huffman:");
        codes.forEach((k,v)-&gt; System.out.println("'" + k + "' : " + v));

        String encoded = encode(message, codes);
        System.out.println("\nOriginal: " + message);
        System.out.println("Codificado: " + encoded);

        String decoded = decode(encoded, root);
        System.out.println("Decodificado: " + decoded);
    }
}
</pre>

          <h3>Ejemplo de uso y resultado esperado</h3>
          <p>Con la cadena <code>"hola mundo"</code> el programa calculará las frecuencias de cada carácter, construirá el árbol Huffman, imprimirá los códigos asignados a cada carácter y mostrará la versión codificada (secuencia de bits). Al decodificar esa secuencia con el mismo árbol recuperaremos exactamente el texto original.</p>

          <p class="small">Nota: si se usan caracteres con acentos o diferentes mayúsculas, se considerarán símbolos distintos en el mapa de frecuencias.</p>
        </section>

        <section id="presaberes" class="card">
          <h2>Presaberes Requeridos (Test y respuestas)</h2>
          <p>Estas preguntas verifican conocimientos básicos previos que la guía asume.</p>
          <ol>
            <li><strong>¿Qué es un grafo?</strong>
              <p class="small">Respuesta correcta: <em>Un conjunto de vértices y aristas, tal que cada arista está asociada a un par</em>.</p>
            </li>
            <li><strong>¿Qué define mejor un árbol binario?</strong>
              <p class="small">Respuesta correcta: <em>Un árbol binario es un árbol con raíz en el que cada vértice tiene ningún hijo, un hijo o dos hijos.</em></p>
            </li>
            <li><strong>En los recorridos de un árbol, ¿cuál recorre primero los subárboles y luego la raíz?</strong>
              <p class="small">Respuesta: <strong>Post-Orden</strong>.</p>
            </li>
          </ol>
        </section>

        <section id="preguntas-orientadoras" class="card">
          <h2>Preguntas Orientadoras</h2>
          <h3>1. ¿Cuáles fueron los aprendizajes obtenidos al realizar esta guía?</h3>
          <ul>
            <li><strong>Modelado de datos jerárquicos:</strong> Aprendí a representar sistemas reales mediante árboles, lo que facilita la organización y recuperación de información.</li>
            <li><strong>Programación recursiva y recorridos:</strong> La práctica consolidó el uso de recursión para operaciones sobre estructuras no lineales.</li>
            <li><strong>Optimización y diseño algorítmico:</strong> Comprendí la importancia de elegir la estructura adecuada (AVL, B, B+) según requisitos de rendimiento y memoria.</li>
          </ul>
          <p><strong>Relación con el ejercicio profesional:</strong> Estas habilidades son útiles en desarrollo backend, diseño de bases de datos, sistemas embebidos y compresión de datos; permiten construir sistemas más eficientes y mantenibles.</p>

          <h3>2. ¿Dónde presenté mayor dificultad y cómo la resolví?</h3>
          <p>La mayor dificultad se presentó en entender y aplicar correctamente las rotaciones para mantener el balance en árboles AVL y en visualizar el orden de los recorridos recursivos. Se solucionó mediante:</p>
          <ul>
            <li>Descomponer problemas en ejemplos pequeños y trazar manualmente los pasos.</li>
            <li>Instrumentar el código con impresiones (prints) para observar el flujo de ejecución.</li>
            <li>Consultar fuentes académicas y comparar implementaciones de referencia.</li>
          </ul>
        </section>

        <section id="trabajo-autonomo" class="card">
          <h2>Actividad de Trabajo Autónomo</h2>
          <p><strong>Tarea:</strong> Visualizar el video <a href="https://www.youtube.com/watch?v=youbCYe3N3g" target="_blank" rel="noopener">"Errores que se cometen como desarrollador"</a> y redactar un resumen en inglés (media página).</p>

          <h3>Resumen (Inglés) — ejemplo (media página)</h3>
          <p>The video "Mistakes Developers Make" highlights frequent pitfalls that reduce software quality and team productivity. Key issues discussed include poor coding standards (inconsistent naming, lack of modularization), insufficient automated testing, and neglecting documentation. The speaker also points out that weak communication and lack of code reviews contribute to project delays and defects. Additionally, the video warns against overengineering and ignoring edge-cases or security concerns. Recommended practices include adopting coding conventions, writing unit tests, using version control properly, conducting regular code reviews, and continuous learning. Overall, the message encourages a disciplined, collaborative approach to software development to minimize errors and improve long-term success.</p>
        </section>

        <section id="bibliografia" class="card">
          <h2>Bibliografía y Fuentes Consultadas</h2>
          <ul>
            <li>Joyanes Aguilar, L. (2008). <em>Estructuras de Datos en Java</em>. McGraw-Hill.</li>
            <li>Blancarte, O. (2014). <em>Estructura de datos - Árboles</em>. Blog: oscarblancarteblog.com</li>
            <li>Slideshare - Unidad v Árboles (ejemplos y visualizaciones).</li>
            <li>Video: "Errores que se cometen como desarrollador" (YouTube).</li>
            <li>Documentación interna de la Universidad Manuela Beltrán — Guía de laboratorio No.7.</li>
          </ul>
        </section>

        <footer>
          <div style="color:var(--muted); font-size:13px;">Guía No.7 — Estructuras de Datos • Universidad Manuela Beltrán</div>
        </footer>
      </div>
    </main>
  </div>

  <script>
    // Theme toggle with persistence
    const root = document.documentElement;
    const stored = localStorage.getItem('site-theme');
    if (stored === 'dark') root.classList.add('dark');

    document.getElementById('theme-toggle').addEventListener('click', () => {
      root.classList.toggle('dark');
      localStorage.setItem('site-theme', root.classList.contains('dark') ? 'dark' : 'light');
    });

    // Smooth scroll for TOC
    document.querySelectorAll('a[href^="#"]').forEach(a=>{
      a.addEventListener('click', (e)=>{
        const target = document.querySelector(a.getAttribute('href'));
        if(target){ e.preventDefault(); target.scrollIntoView({behavior:'smooth', block:'start'}); }
      });
    });
  </script>
</body>
</html>
